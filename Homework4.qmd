---
title: "ST558 Homework #4"
author: "Trevor Lynch"
format: html
editor: visual
---

# Task 1: Conceptual Questions
> 1. The purpose of the `lapply()`function is to apply a function to every element of a list, and output a list object. The equivalent function in the `purrr` package is `map(list_here, function_here)`.  
> 2. The code to apply the cor() function, with a method = "kendall" option, to each element of the my_list object would be: `lapply(X = my_list, FUN = cor, method = "kendall")`
> 3. One advantage of using the `purrr` package instead of `BaseR` apply functions is that is never any ambiguity in what type of output you will receive, deoending on the functions you use. Whereas with `sapply()` for example, we may not know what the output type will be. Another advantage of the `purrr` package is the functions allow for inline anonymous function writing within the function calls.
> 4. A side-effect function is a function that, when called, will produce an output but not change the data. For example, the `print()` or `plot()` functions.
> 5. A variable inside can be named `sd` without any conflict from the sd function because the `sd` variable is assigned locally within the function. This means that if `sd` is called outside of the function it will call the BaseR function rather than call the `sd` object saved within the other function. 

# Task 2: Writing R Functions
1. Write the getRMSE() function to take in 2 vectors and output the Root Mean Square Error. We need to allow for the option to be specified if we want missing values to be removed from the data before calculating.
```{r}
getRMSE <- function(responses, preds, ...){
  sqd_diffs <- (responses - preds)^2
  RMSE <- sqrt(mean(sqd_diffs, ...))
  return(RMSE)
}
```

2. Test the getRMSE() function, replace 2 responses with missing values and repeat the test specifying different ways to treat the missing values.
```{r}
# Artificially generate some response  and prediction values
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10*x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

# Test the getRMSE() function, replace 2 responses with missing values and repeat the test specifying different ways to treat the missing values
getRMSE(resp,pred)

new_resp <- replace(resp,c(1,2), NA_real_)

# Test the function while specifying, or not specifying, to remove missing values
getRMSE(new_resp, pred)
# Removing missing values and retesting
getRMSE(new_resp, pred, na.rm = TRUE)
```

3.  Write the getMAE() function to take in 2 vectors and output the Mean Absolute Deviation. We need to allow for the option to be specified if we want missing values to be removed from the data before calculating.
```{r}
getMAE <- function(responses, preds, ...){
  abs_diffs <- abs(responses - preds)
  MAE <- mean(abs_diffs, ...)
  return(MAE)
}
```

4. Test the getMAE() function, replace 2 responses with missing values and repeat the test specifying different ways to treat the missing values.
```{r}
# Artificially generate some response  and prediction values
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10*x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

# Test the getRMSE() function, replace 2 responses with missing values and repeat the test specifying different ways to treat the missing values
getMAE(resp,pred)

new_resp <- replace(resp,c(1,2), NA_real_)

# Test the function while specifying, or not specifying, to remove missing values
getMAE(new_resp, pred)
# Removing missing values and retesting
getMAE(new_resp, pred, na.rm = TRUE)
```

5. Create a wrapper function that calls both of the function above and outputs the solution for the function(s) that is/are requested in the function call.
```{r}


```

6. 
```{r}
#| echo: false
2 * 2
```


# Task 3: Querying an API and Tidy-Style Function
1. 
```{r}
#| echo: false
2 * 2
```

2. 
```{r}
#| echo: false
2 * 2
```

3. 
```{r}
#| echo: false
2 * 2
```